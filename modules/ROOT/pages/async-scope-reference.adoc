= Async Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: Async, scopes, studio, anypoint

The Async scope is a branch processing block that executes simultaneously with the main flow. The main flow continues to execute while it initiates the Async scope and processing takes places with in Async. The flow does wait for the last processor within the asynchronous flow to completes its tasks.

Async is useful for executing time-consuming operations that do not require a response to the initiating flow, for example, when printing a file or connecting to an email server.

To facilitate simultaneous branch processing, the Async scope sends one copy of the Mule event (the Mule message and any Mule variables) it receives to the first processor within its processing block. At the same time, the scope sends another copy of this event to the next processor in the main flow.

image::async-scope-schematic.png[Async+scope+schematic]

Because the Async scope executes in a "fire and forget" manner, the result of the processing within the scope is not available in the main flow. Mule variables created within the flow do not propagate to the main flow, nor do any changes to the payload or other parts of the Mule event. 

== Reference

Async scopes are configurable.

[%header,cols="1a,1a,1a,4a"]
|===
| Field | XML | Default | Description
| *Display Name* | `name` | Async | Name for the Async scope.
| *Max Concurrency* | `maxConcurrency` | See description. |  Optional. Sets the maximum number of concurrent Mule messages or variables that the scope can process. By default, the container thread pool optimizes performance by determinng the maximum number of threads to use. 

Setting `maxConcurrency` to `1` causes the scope to process requests one at a time.

Upon reaching maximum concurrency,the scope cannot receive additional requests. See xref:execution-engine.adoc#backpressure[Back-Pressure Management] for details about the behavior of Mule when it reaches the maximum concurrency value.
|===

== Async Scopes versus Subflows

Unlike the xref:flow-component.adoc[Subflow}, the Async scope:

* Does not inherit the exception strategy of the main flow.
+
To handle errors in an Async scope, use the xref:try-scope-concept.adoc[Try scope].
+
* Processes messages asynchronously.
* Does not pass data back to the main flow.
* Exists inline with the main flow thread.
* Is not called by a xref:flowref-about.adoc[Flow Reference] component.
* Is not reusable.


// TODO: DOES THIS INFO BELONG IN THIS SECTION?
// TODO: Do we have a recommendation here?
Though the Async scope receives a copy of the Mule message, Mule does not copy the payload. Instead, each Mule message references the same payload. One payload continues in the main flow, and the other is processed within the Async scope. So if the payload of your message is a mutable object (for example, a bean with different fields in it) and a message processor in your Async scope changes the value of one of the fields, the message processors outside of the Async scope see the changed values.


== Example Async Scope Configuration

The following XML fragment shows an example configuration of an Async scope inside an application flow. The Async scope contains a `file:read` operation that executes asynchronously once triggered, while the application continues processing the next operation in the flow, `http:request`:

[source,xml,linenums]
----
<!-- Main application flow -->
<flow name="myMainFlow" >
  <!-- HTTP Listener as message source -->
  <http:listener doc:name="Listener" />
  <!-- A Transform operation that executes as part of the main flow -->
  <ee:transform doc:name="Transform Message" >
    <ee:message >
      <ee:set-payload >
        <![CDATA[%dw 2.0
        output application/json
        ---
        payload]]>
      </ee:set-payload>
    </ee:message>
  </ee:transform>
    <!-- The Async scope executes its message processors in a different thread, while the main flow continues its execution -->
    <async doc:name="Async" >
      <!-- A Try scope to handle errors, because the async scope does not inherit the error strategy from the flow -->
      <try doc:name="Try" >
        <!-- A Write operation -->
        <file:write doc:name="Write" path="/" />
        <!-- Error handling strategy defined in the Try scope, to handle errors during the Async scope execution -->
        <error-handler >
          <on-error-continue enableNotifications="true" logException="true" doc:name="On Error Continue" type="ANY">
            <!-- Some error handling logic for this strategy -->
            ...
          </on-error-continue>
        </error-handler>
      </try>
    </async>
  <!-- This HTTP Request operation starts executing without waiting for the Async scope to finish its execution -->
  <http:request method="GET" doc:name="Request" />
  ...
</flow>
----

== See Also

* xref:about-components.adoc[Core Components]
* xref:transaction-management.adoc#tx_scopes_routers[How Transactions Affect Scopes and Routers]
* xref:tuning-backpressure-maxconcurrency.adoc[Back-Pressure and MaxConcurrency]
