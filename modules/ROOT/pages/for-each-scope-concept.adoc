= For Each Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:page-aliases: for-each-scope-xml-reference.adoc

The For Each scope splits a payload into elements and processes them one by one through the components that you place in the scope.
It is similar to a `for-each`/`for` loop code block in most programming languages and can process any collection, including lists and arrays.
The collection can be any supported content type, such as `application/json`, `application/java`, or `application/xml`.


General considerations about the For Each scope:

* By default, For Each tries to split the payload of the input. If the payload is a simple Java collection, the For Each scope can split it without any configuration. The payload inside the For Each scope is each of the split elements.
* For Each ignores attributes but accepts all variables of the input.
* For Each does not modify the input payload. The output payload is the same as the input.
//TODO: Next bullet not re non-Java collections NOT TRUE.
// The scope splits both a JSON and XML payload.
* For non-Java collections, such as XML or JSON, use a DataWeave expression to split data. Use the *Collection* field for this purpose.
+
In the following example, the *Collection* field in For Each is set to iterate over an array stored in `payload.topics`:
+
[[studio_example]]
image::component-foreach-example.png[For Each Component]

The For Each scope stores each item of the collection in `payload` during each iteration.


You can also split an array into batches to enable quicker processing. Each batch is treated as a separate Mule message. For example, if a collection has 200 elements and you set *Batch Size* (`batchSize`) to `50`, the For Each scope iteratively processes 4 batches of 50 elements, each as a separate Mule message.

This following XML example is based on the <<studio_example, For Each scope configuration in the shown in the Studio UI>>:

[source,xml,linenums]
----
...
  <foreach doc:name="For Each" collection="#[payload.topics]" batchSize="1" rootMessageVariableName="rootMessage" counterVariableName="counter">
      <file:write ... >
      <!--Any other module that you want to include in the For Each scope -->
  </foreach>
...
----

== Variable Propagation

//TODO: "of the block"?
Every execution of the For Each scope starts with the variables and values
from the previous execution of the block. New variables or modifications
to existing variables that take place when processing one element are visible
during the processing of another element. These changes to variables continue
to be available outside the For Each scope.

[source,xml,linenums]
----
<set-variable variableName="var1" value="var1"/>
<set-variable variableName="var2" value="var2"/>
<foreach collection="#[['apple', 'banana', 'orange']]">
    <choice>
        <when expression="#[payload == 'apple']">
            <set-variable variableName="var2" value="newValue"/>
            <set-variable variableName="var3" value="appleVal"/>
        </when>
        <when expression="#[payload == 'banana']">
            <set-variable variableName="var3" value="#[vars.var3 ++ ' bananaVal']"/>
            <!-- var3 will now have value 'appleVal bananaVal'-->
        </when>
        <otherwise>
            <set-variable variableName="var3" value="otherVal"/>
            <set-variable variableName="var4" value="val4"/>
        </otherwise>
    </choice>
</foreach>
----

After aggregation, the variables are:
//TODO: "After aggregation"?
// WHAT AGGREGATION? FOR EACH DOESN'T AGGREGATE, does it?
// The variable values outside the block would
// be "var1", "var2", "otherVal", "val4" (meaning there's no "newValue")

[source,json,linenums]
----
{var1: "var1", var2: "newValue", var3: "otherVal", var4: "val4"}
----

== Error Handling

If one of the elements in a collection throws an exception, the For Each scope stops processing that collection and invokes the error handler.

See xref:on-error-scope-concept.adoc[] for information about Mule error handlers.

== Example Projects

There are several example projects in https://www.mulesoft.com/exchange/[Anypoint Exchange^] that you can open in xref:studio::import-project-exchange.adoc[Anypoint Studio] to learn more about how to use the For Each scope:

//TODO: ADD LINKS TO THE EXAMPLES?
* _Authenticating Salesforce using OAuth2_
* _Import contacts into Microsoft Dynamics CRM_
* _Importing a CSV file into mongoDB_
* _Importing an Email Attachment using the IMAP Connector_
* _Importing Email Attachments using the POP3 Connector_
* _Querying a Database and Attaching Results to an Email_

To download and open an example project while you are in Anypoint Studio, click the Exchange icon in the upper-left corner. Then, in the window that opens, log into Anypoint Exchange and search for the name of the project.

== XML Reference

For Each scopes use the `<foreach/>` tag. Components that are affected by this scope are defined as child elements of this tag.

=== Configurable Properties

[%header,cols="1a,1a,1a,4a"]
|===
| Field Name | XML | Default | Description

| *Collection*
| `collection`
| `payload`
| A DataWeave expression that returns a Java collection, object, array, map, or DOM nodes.

| *Counter Variable Name*
| `counterVariableName`
| `counter`
| Name of the variable that assigns a number to each message over which the scope iterates. The sequence starts with `1` for the first processed message and proceeds sequentially based on the order in which the message is processed within the scope. When using the default value, you can access this number with `vars.counter`.

| Batch Size
| `batchSize`
| `1`
| Partitions the collection into sub-collections of the specified
 size. For example, if a collection has 200 elements and you set the batch size to 50, it processes 4 batches of 50 elements each.

| *Root Message Variable Name*
| `rootMessageVariableName`
| `rootMessage`
| Name of the property that stores the input to the For Each component. This Mule event contains the complete, non-split message. Within For Each, you can gain access to the value of the input payload with `vars.rootMessage.payload` if you are using the default value, `rootMessage`. After For Each, use `payload` to access the value of the input to For Each.
|===


////
=== Iterate a JSON Array

[source,xml,linenums]
----
include::{examplesdir}/for-each-scope-concept_1.xml[]
----

In this case, the payload contains a JSON array. For Each iterates over the payload because the `collection` attribute has not been defined. The payload within For Each is each of the users in the JSON array.

=== Iterate over a Java Map that is Placed in a Variable

[source,xml,linenums]
----
include::{examplesdir}/for-each-scope-concept_2.xml[]
----

The example uses the `ee:transform` to set a variable named `users` with a Java map that is created with DataWeave. Then it uses a built-in DataWeave function to get the entries of a map as a collection in order to iterate over it.

=== Split a Collection into Batches

[source,xml,linenums]
----
include::{examplesdir}/for-each-scope-concept_3.xml[]
----

The `batchSize` attribute creates sub-arrays of two elements. So inside `foreach`, the payload will have an array of two elements.

=== Aggregate the Process of Each Element into a Variable

[source,xml,linenums]
----
include::{examplesdir}/for-each-scope-concept_4.xml[]
----

Within the For Each, the example creates an `aggregation` variable that concatenates the name in reverse. Then that variable can be accessed outside the For Each scope.

////

////
EDGE CASE? OUT IN 4.0, PER DAN F. IF THERE'S A REQUEST TO RESTORE IT, WE MIGHT RESTORE IT
== Persisting Data

In case the message inside the For Each scope is persisted, not only the item in the collection is serialized but also all the variables associated with it. The rootMessage variable, associated with the message, contains a reference to the complete, unsplit collection. Therefore, serialization/deserialization of the rootMessage variable could impact memory consumption considerably when this collection is large enough.

To avoid this issue you must first remove the rootMessage variable from the message before persisting it.
////

include::partial$parallelforeach_vs_foreach.adoc[]

See xref:parallel-foreach-scope.adoc[Parallel For Each Scope].

== See Also

* xref:about-mule-event.adoc[Mule Events]
* xref:about-mule-message.adoc[Mule Message Structure]
